# Minimal, explicit Ninja build for a C++23 module-based runtime/library.
# This file is intended to be read and edited by humans.

# --- Compiler and flags (single, clearly labeled section) ---
# Target: Linux, GCC, C++23, named modules only, no libc reliance assumed.
# The module cache is explicit and kept in build/gcm.cache.
cxx = g++
mod_cache = build/gcm.cache

# Common flags for all compilation steps.
# -std=c++23: language level
# -fmodules-ts: enable named modules (GCC's modules TS support)
# -fmodule-mapper=... not used; explicit order is declared by build edges
# -fmodule-only: for module interface compilation (see rule below)
# -fmodules-cache-path: explicit cache location
# -ffreestanding/-nostdlib: intended for toolchain/runtime-style components
# -Wall -Wextra: basic warnings for clarity
cxxflags_common = -std=c++23 -fmodules-ts -fmodules-cache-path=$mod_cache -ffreestanding -nostdlib -Wall -Wextra

# Separate flags for module interface units and normal translation units.
cxxflags_module = $cxxflags_common -fmodule-only
cxxflags_source = $cxxflags_common

# --- Rules ---
# Compile a module interface (.cppm) into an object file and its BMI in the cache.
# The BMI is emitted into build/gcm.cache; Ninja uses explicit build ordering
# to ensure consumers are compiled after the module interface.
rule compile_module
  command = $cxx $cxxflags_module -c $in -o $out
  description = CXX MODULE $in

# Compile a normal .cpp that imports modules.
# This relies on the module cache being populated by prior module builds.
rule compile_source
  command = $cxx $cxxflags_source -c $in -o $out
  description = CXX SOURCE $in

# Archive objects into a static library.
rule archive
  command = ar rcs $out $in
  description = AR $out

# --- Build edges (explicit order for modules) ---
# Example layout:
#   modules/posixpp.cppm       (module interface)
#   src/runtime.cpp            (imports posixpp)
#   src/new_delete.cpp          (custom operator new/delete)
#   src/startup.cpp             (startup glue)

# Build the module interface first so its BMI exists in build/gcm.cache
# before any source file imports it.
build build/posixpp.pcm.o: compile_module modules/posixpp.cppm

# Normal sources that import the module depend on the module build edge.
# This explicit dependency enforces module compilation order.
build build/runtime.o: compile_source src/runtime.cpp | build/posixpp.pcm.o
build build/new_delete.o: compile_source src/new_delete.cpp | build/posixpp.pcm.o
build build/startup.o: compile_source src/startup.cpp | build/posixpp.pcm.o

# Archive all objects into the static library.
build build/libposixpp.a: archive build/posixpp.pcm.o build/runtime.o build/new_delete.o build/startup.o

# Optional test executable (if you have src/test.cpp that imports modules).
# Uncomment and adapt as needed.
# build build/test.o: compile_source src/test.cpp | build/posixpp.pcm.o
# build build/test: link build/test.o build/libposixpp.a

# rule link
#   command = $cxx $cxxflags_common -nostdlib $in -o $out
#   description = LINK $out

# Default target.
default build/libposixpp.a
